{"version":3,"sources":["../src/any.ts","../src/array.ts","../src/boolean.ts","../src/index.ts","../src/number.ts","../src/object.ts","../src/ok.ts","../src/string.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["export interface ValidationErrorObject {\n  [key: string]: ValidationError;\n}\n\nexport type ValidationError = string | ValidationErrorObject;\n\ninterface ResultValid {\n  valid: true;\n  error: null;\n  validationError: null;\n}\n\ninterface ResultInvalidBase {\n  valid: false;\n}\n\ninterface ResultInvalidPrimitive extends ResultInvalidBase {\n  error: string;\n}\n\ninterface ResultInvalidObject extends ResultInvalidBase {\n  error: ValidationErrorObject;\n}\n\ntype ResultInvalid = ResultInvalidPrimitive | ResultInvalidObject;\n\nexport type Result = ResultValid | ResultInvalid;\n\ninterface TestContext<Parent, Root> {\n  parent: Parent;\n  root: Root;\n  path: string[];\n}\n\ntype TestFnResult = OKAny | string | false | null | undefined | void;\n\ntype SyncTestFn<Input, Parent, Root> = (\n  val: Input,\n  context: TestContext<Parent, Root>\n) => TestFnResult;\n\ntype AsyncTestFn<Input, Parent, Root> = (\n  val: Input,\n  context: TestContext<Parent, Root>\n) => Promise<TestFnResult>;\n\ntype TestFn<Input, Parent, Root> =\n  | SyncTestFn<Input, Parent, Root>\n  | AsyncTestFn<Input, Parent, Root>;\n\ninterface Test<Input, Parent, Root> {\n  testFn: TestFn<Input, Parent, Root>;\n  skipIfNull?: boolean;\n}\n\nexport type TransformFn<Input, Parent, Root> = (\n  val: Input,\n  context: TestContext<Parent, Root>\n) => any;\n\nfunction checkNullish(value: unknown) {\n  // null, undefined, empty string all considered nullish\n  return value === null || value === undefined || (value as string) === '';\n}\n\nfunction isString(val: any): val is string {\n  return typeof val === 'string';\n}\n\nclass OKAny<Input = unknown, Parent = unknown, Root = unknown> {\n  /* Instance keeping track of stuff */\n  private isOptional = false;\n  private requiredMessage = 'Required';\n\n  protected tests: Test<Input, Parent, Root>[] = [];\n\n  protected transforms: TransformFn<Input, Parent, Root>[] = [];\n\n  // @internal\n  public __parent: Parent | undefined;\n  // @internal\n  public __root: Root | undefined;\n  // @internal\n  public __path: string[] = [];\n\n  public constructor() {}\n\n  /* Internal */\n\n  protected error(msg: string): ResultInvalidPrimitive;\n  protected error(msg: ValidationErrorObject): ResultInvalidObject;\n  protected error(msg: (string | null)[]): ResultInvalidObject;\n  protected error(msg: (ValidationErrorObject | null)[]): ResultInvalidObject;\n  protected error(\n    msg:\n      | string\n      | ValidationErrorObject\n      | (string | null)[]\n      | (ValidationErrorObject | null)[]\n  ) {\n    return { valid: false, error: msg };\n  }\n\n  protected success(): ResultValid {\n    return { valid: true, error: null, validationError: null };\n  }\n\n  protected getContext(): TestContext<Parent, Root> {\n    const parent = this.__parent as Parent;\n    const root = this.__root as Root;\n    const path = this.__path;\n    return { parent, root, path };\n  }\n\n  // If the predicate returns true, the test passes, and the value is ok\n  // if it returns false, the error message will be returned\n  // These tests will be skipped if the value is null and field is marked\n  // optional, because it doesn't make sense to apply them to a null value\n  protected makeAddTest = <T = unknown>() => (\n    predicate: (v: T) => boolean,\n    msg: string\n  ) => {\n    const testFn = (val: Input) => (predicate(val as any) ? null : msg);\n    this.tests.push({ testFn, skipIfNull: true });\n  };\n\n  /**\n   * Mark schema as optional, meaning that empty string, null, and undefined\n   * are valid values\n   */\n  public optional() {\n    this.isOptional = true;\n    return this;\n  }\n\n  /**\n   * Add a tranformation to the schema.  The transformation will be run before\n   * any of the tests\n   * @param transformFn A function that returns the updated value\n   */\n  public transform(transformFn: TransformFn<Input, Parent, Root>) {\n    this.transforms.push(transformFn);\n    return this;\n  }\n\n  /**\n   * Add an arbitrary test to the schema\n   * @param testFn A function which will be passed the current value, and\n   * should return an error message string if there is an error.  If a schema\n   * is returned, it will be executed and the result used.\n   */\n  public test(testFn: TestFn<Input, Parent, Root>): OKAny<Input, Parent, Root> {\n    this.tests.push({ testFn });\n    return this;\n  }\n\n  /**\n   * Fields are considered required by default.  If you want to customize the\n   * error message, you can use this method.\n   * @param msg Error message if field is empty (empty string, null, undefined)\n   */\n  public required(msg?: string) {\n    if (msg) {\n      this.requiredMessage = msg;\n    }\n    return this;\n  }\n\n  /**\n   * Attempt to cast the input into the schema shape.  All transforms will be\n   * run, and the result returned, or an error thrown.\n   * @param input The object to be cast\n   */\n  public cast(input: Input) {\n    const context = this.getContext();\n    return this.transforms.reduce(\n      (prevValue, fn) => fn(prevValue, context),\n      input\n    );\n  }\n\n  /**\n   * Validate an object.  All transforms will be run, then all tests will\n   * be run, and a result object will be returned.  If all the tests pass,\n   * valid will be true, and error will be null.  If any test fails, valid\n   * will be false, and error will contain the all the errors that occured.\n   * @param input The object to be validated\n   */\n  public validate(input: Input): Result {\n    const value = this.cast(input);\n\n    const isNullish = checkNullish(value);\n    if (isNullish && !this.isOptional) {\n      return this.error(this.requiredMessage);\n    }\n\n    const context = this.getContext();\n    for (const { testFn, skipIfNull } of this.tests) {\n      if (isNullish && skipIfNull) {\n        continue;\n      }\n      const res = testFn(value, context);\n      if (res instanceof Promise)\n        return this.error(\n          'Cannot run async test in validate, use validateAsync'\n        );\n      else if (res instanceof OKAny) return res.validate(value);\n      else if (isString(res)) return this.error(res);\n    }\n\n    return this.success();\n  }\n\n  /**\n   * Validate an object asynchronously.  All transforms will be run, then all\n   * tests will be run, and a promise for the result object will be returned.\n   * If all the tests pass, valid will be true, and error will be null.  If\n   * any test fails, valid will be false, and error will contain the all the\n   * errors that occured.\n   * @param input The object to be validated\n   */\n  public async validateAsync(input: Input): Promise<Result> {\n    const value = this.cast(input);\n\n    const isNullish = checkNullish(value);\n    if (isNullish && !this.isOptional) {\n      return this.error(this.requiredMessage);\n    }\n\n    const context = this.getContext();\n    const testResults = await Promise.all(\n      this.tests.map(async ({ testFn, skipIfNull }) => {\n        if (isNullish && skipIfNull) {\n          return null;\n        }\n        const res = await testFn(value, context);\n        if (res instanceof OKAny)\n          return res.validateAsync(value).then(r => r.error);\n        else if (isString(res)) return res;\n        else return null;\n      })\n    );\n    const firstError = testResults.filter(isString)[0];\n    if (firstError) return this.error(firstError);\n    else return this.success();\n  }\n}\n\nexport default OKAny;\n","import OKAny, { Result } from './any';\n\nclass OKArray<Input, Parent, Root> extends OKAny<Input, Parent, Root> {\n  private shape: OKAny;\n  private parseErrorMsg = 'Must be an array';\n\n  public constructor(shape: OKAny, msg?: string) {\n    super();\n    this.shape = shape;\n    if (msg) this.parseErrorMsg = msg;\n    this.addTest(v => Array.isArray(v), this.parseErrorMsg);\n  }\n\n  private addTest = this.makeAddTest<unknown[]>();\n\n  private setContext(input: Input, ndx: number) {\n    // If input in null return immediately\n    if (!input) return;\n    this.shape.__parent = (input as unknown) as Parent;\n    // If this already has a root, pass in that one\n    this.shape.__root = this.__root || ((input as unknown) as Root);\n    this.shape.__path = this.__path.concat(String(ndx));\n  }\n\n  public validate(input: Input): Result {\n    // Generic validation\n    const superRes = super.validate(input);\n    if (!superRes.valid) return superRes;\n\n    const errors = ((input as unknown) as any[]).map((el, ndx) => {\n      this.setContext(input, ndx);\n      return this.shape.validate(el);\n    });\n\n    const foundError = errors.some(e => !e.valid);\n    // typescript cannot comprehend that they are all of the same type\n    if (foundError) return this.error(errors.map(e => e.error) as any[]);\n\n    return this.success();\n  }\n\n  public async validateAsync(input: Input): Promise<Result> {\n    // Generic validation\n    const superRes = await super.validateAsync(input);\n    if (!superRes.valid) return superRes;\n\n    const errors = await Promise.all(\n      ((input as unknown) as any[]).map((el, ndx) => {\n        this.setContext(input, ndx);\n        return this.shape.validateAsync(el);\n      })\n    );\n\n    const foundError = errors.some(e => !e.valid);\n    // typescript cannot comprehend that they are all of the same type\n    if (foundError) return this.error(errors.map(e => e.error) as any[]);\n\n    return this.success();\n  }\n\n  // Override cast behavior so that all elements get cast\n  public cast(input: Input) {\n    // If we are trying to cast something that is not an array give up\n    if (!Array.isArray(input)) {\n      return input;\n    }\n    return (input.map(el => this.shape.cast(el)) as unknown) as Input;\n  }\n\n  /**\n   * Verify that the array is an exact length\n   * @param len required length of array\n   * @param msg error message if test fails\n   */\n  public length(len: number, msg?: string) {\n    this.addTest(v => v.length === len, msg || `Must have length ${len}`);\n    return this;\n  }\n\n  /**\n   * Verify that the array is at least a certain length\n   * @param min the minimum valid length\n   * @param msg error message if test fails\n   */\n  public min(min: number, msg?: string) {\n    this.addTest(\n      v => v.length >= min,\n      msg || `Must have length greater than or equal to ${min}`\n    );\n    return this;\n  }\n\n  /**\n   * Verify that the array is at most a certain length\n   * @param max the maximum valid length\n   * @param msg error message if test fails\n   */\n  public max(max: number, msg?: string) {\n    this.addTest(\n      v => v.length <= max,\n      msg || `Must have length less than or equal to ${max}`\n    );\n    return this;\n  }\n}\n\nexport default OKArray;\n","import OKAny, { TransformFn } from './any';\n\nconst parseBoolean = (val: unknown) => {\n  if (typeof val === 'string') {\n    // For strings, any string of spaces is considered empty\n    const isEmpty = val.trim() === '';\n    if (isEmpty) return null;\n    // If it isn't empty, check if it is the string true or false\n    else if (val === 'true') return true;\n    else if (val === 'false') return false;\n    else return val;\n  }\n  // Everything else is returned directly\n  return val;\n};\n\nclass OKBoolean<Input, Parent, Root> extends OKAny<Input, Parent, Root> {\n  public constructor(\n    msg?: string,\n    transform?: TransformFn<Input, Parent, Root>\n  ) {\n    super();\n    if (transform) {\n      this.transform(transform);\n    } else {\n      this.transform(parseBoolean);\n    }\n    this.addTest(v => typeof v === 'boolean', msg || 'Must be a boolean');\n  }\n\n  private addTest = this.makeAddTest<boolean>();\n}\n\nexport default OKBoolean;\n","import ok from './ok';\n\nexport default ok;\n","import OKAny, { TransformFn } from './any';\n\nconst parseNumber = (val: unknown) => {\n  if (typeof val === 'string') {\n    // For strings, any string of spaces is considered empty\n    const isEmpty = val.trim() === '';\n    if (isEmpty) return null;\n    // If it isn't empty, it is parsed with Number\n    else return Number(val);\n  }\n  // Numbers, null, undefined are returned directly\n  if (typeof val === 'number' || val === null || val === undefined) return val;\n  // Everything else is considered not a number\n  return NaN;\n};\n\nclass OKNumber<Input, Parent, Root> extends OKAny<Input, Parent, Root> {\n  public constructor(\n    msg?: string,\n    transform?: TransformFn<Input, Parent, Root>\n  ) {\n    super();\n    if (transform) {\n      this.transform(transform);\n    } else {\n      this.transform(parseNumber);\n    }\n    this.addTest(\n      v => typeof v === 'number' && !Number.isNaN(v),\n      msg || 'Must be a number'\n    );\n  }\n\n  private addTest = this.makeAddTest<number>();\n\n  /**\n   * Verify that the number is greater than a value\n   * @param min minimum value\n   * @param msg error message if test fails\n   */\n  public min(min: number, msg?: string) {\n    this.addTest(\n      v => v >= min,\n      msg || `Must be greater than or equal to ${min}`\n    );\n    return this;\n  }\n\n  /**\n   * Verify that the number is less than a value\n   * @param max maximum value\n   * @param msg error message if test fails\n   */\n  public max(max: number, msg?: string) {\n    this.addTest(v => v <= max, msg || `Must be less than or equal to ${max}`);\n    return this;\n  }\n\n  /**\n   * Verify that the number is less than a value\n   * @param max maximum value\n   * @param msg error message if test fails\n   */\n  public lessThan(max: number, msg?: string) {\n    this.addTest(v => v < max, msg || `Must be less than ${max}`);\n    return this;\n  }\n\n  /**\n   * Verify that the number is greater than a value\n   * @param min minimum value\n   * @param msg error message if test fails\n   */\n  public moreThan(min: number, msg?: string) {\n    this.addTest(v => v > min, msg || `Must be greater than ${min}`);\n    return this;\n  }\n\n  /**\n   * Verify that the number is greater than zero\n   * @param msg error message if test fails\n   */\n  public positive(msg?: string) {\n    this.addTest(v => v > 0, msg || `Must be positive`);\n    return this;\n  }\n\n  /**\n   * Verify that the number is less than zero\n   * @param msg error message if test fails\n   */\n  public negative(msg?: string) {\n    this.addTest(v => v < 0, msg || `Must be negative`);\n    return this;\n  }\n\n  /**\n   * Verify that the number is an integer\n   * @param msg error message if test fails\n   */\n  public integer(msg?: string) {\n    this.addTest(v => Number.isInteger(v), msg || 'Must be an integer');\n    return this;\n  }\n}\n\nexport default OKNumber;\n","import OKAny, { ValidationError, Result } from './any';\n\nexport interface Shape<Input> {\n  [key: string]: OKAny<Input>;\n}\n\ninterface UnknownObj {\n  [key: string]: unknown;\n}\n\nfunction isObject(v: unknown) {\n  return typeof v === 'object' && v !== null && !Array.isArray(v);\n}\n\nclass OKObject<Input, Parent, Root> extends OKAny<Input, Parent, Root> {\n  private shape: Shape<Input>;\n  private parseErrorMsg = 'Must be an object';\n\n  public constructor(shape: Shape<Input>, msg?: string) {\n    super();\n    this.shape = shape;\n    if (msg) this.parseErrorMsg = msg;\n    this.addTest(isObject, this.parseErrorMsg);\n  }\n\n  private addTest = this.makeAddTest<{}>();\n\n  // Returns list of shape, with child OK's populated with parent + root\n  private iterateShape(input: Input) {\n    // If input in null return immediately\n    if (!input) return [];\n    return Object.keys(this.shape).map(key => {\n      const ok = this.shape[key];\n      const val: any = (input as UnknownObj)[key];\n      return { ok, val, key };\n    });\n  }\n\n  private setContext(input: Input) {\n    // If input in null return immediately\n    if (!input) return;\n    Object.keys(this.shape).forEach(key => {\n      const ok = this.shape[key];\n      ok.__parent = (input as unknown) as Parent;\n      // If this already has a root, pass in that one\n      ok.__root = this.__root || ((input as unknown) as Root);\n      ok.__path = this.__path.concat(key);\n    });\n  }\n\n  public validate(input: Input): Result {\n    this.setContext(input);\n\n    // Generic validation\n    const superRes = super.validate(input);\n    if (!superRes.valid) return superRes;\n\n    // Each key\n    let foundError = false;\n    const error: ValidationError = {};\n    for (const { ok, val, key } of this.iterateShape(input)) {\n      const res = ok.validate(val);\n      if (!res.valid) {\n        foundError = true;\n        error[key] = res.error;\n      }\n    }\n\n    if (foundError) return this.error(error);\n\n    return this.success();\n  }\n\n  public async validateAsync(input: Input): Promise<Result> {\n    this.setContext(input);\n\n    // Generic validation\n    const superRes = await super.validateAsync(input);\n    if (!superRes.valid) return superRes;\n\n    // Each key\n    let foundError = false;\n    const error: ValidationError = {};\n    await Promise.all(\n      this.iterateShape(input).map(async ({ ok, val, key }) => {\n        const res = await ok.validateAsync(val);\n        if (!res.valid) {\n          foundError = true;\n          error[key] = res.error;\n        }\n      })\n    );\n\n    if (foundError) return this.error(error);\n\n    return this.success();\n  }\n\n  // Override cast behavior so that children get cast\n  public cast(input: Input) {\n    // If we are trying to cast something that is not an object give up\n    if (!isObject(input)) {\n      return input;\n    }\n    const newInput: UnknownObj = {};\n    for (const { ok, val, key } of this.iterateShape(input)) {\n      newInput[key] = ok.cast(val);\n    }\n    const context = this.getContext();\n    return this.transforms.reduce(\n      (prevValue, fn) => fn(prevValue, context),\n      newInput as Input\n    );\n  }\n}\n\nexport default OKObject;\n","import OKAny, { TransformFn } from './any';\nimport OKArray from './array';\nimport OKBoolean from './boolean';\nimport OKNumber from './number';\nimport OKObject, { Shape } from './object';\nimport OKString from './string';\n\nconst ok = {\n  /**\n   * Create \"any\" schema, which will accept any value\n   */\n  any: <Input = any, Parent = any, Root = any>() =>\n    new OKAny<Input, Parent, Root>(),\n  /**\n   * Create an array schema, which will only accept an array\n   * @param shape A schema for the elements of the array\n   * @param msg The error message if the schema is not passed an array\n   */\n  array: <Input = any, Parent = any, Root = any>(shape: OKAny, msg?: string) =>\n    new OKArray<Input, Parent, Root>(shape, msg),\n  /**\n   * Create a boolean schema\n   *\n   * It will accept only booleans, or the strings \"true\" or \"false\"\n   *\n   * @param msg The error message if the schema cannot convert the value to a\n   * boolean\n   *\n   * @param transform Override the default boolean transformation\n   */\n  boolean: <Input = any, Parent = any, Root = any>(\n    msg?: string,\n    transform?: TransformFn<Input, Parent, Root>\n  ) => new OKBoolean<Input, Parent, Root>(msg, transform),\n  /**\n   * Create a number schema\n   *\n   * If the input value is a non empty string, it will be converted to a number\n   * with Number(val)\n   *\n   * If the parsed value is NaN, validation will fail\n   *\n   * @param msg The error message if the schema cannot convert the value to a\n   * number\n   *\n   * @param transform Override the default number transformation\n   */\n  number: <Input = any, Parent = any, Root = any>(\n    msg?: string,\n    transform?: TransformFn<Input, Parent, Root>\n  ) => new OKNumber<Input, Parent, Root>(msg, transform),\n  /**\n   * Create an object schema, which will only accept an object\n   * @param shape A schema for the object\n   * @param msg The error message if the schema is not passed an object\n   */\n  object: <Input = any, Parent = any, Root = any>(\n    shape: Shape<Input>,\n    msg?: string\n  ) => new OKObject<Input, Parent, Root>(shape, msg),\n  /**\n   * Create a string schema\n   *\n   * The input value will be converted to string with String(val)\n   *\n   * The values null and undefined will be left as is\n   * @param msg The error message if the schema cannot convert the value to a\n   * string\n   *\n   * @param transform Override the default string transformation\n   */\n  string: <Input = any, Parent = any, Root = any>(\n    msg?: string,\n    transform?: TransformFn<Input, Parent, Root>\n  ) => new OKString<Input, Parent, Root>(msg, transform),\n};\n\nexport default ok;\n","import OKAny, { TransformFn } from './any';\n\n// from emailregex.com\nconst emailRegex = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n\nconst parseString = (val: unknown) => {\n  if (val === null || val === undefined) return val;\n  else if (typeof val === 'string') return val;\n  else if (typeof val === 'object') return val;\n  else return String(val);\n};\n\nclass OKString<Input, Parent, Root> extends OKAny<Input, Parent, Root> {\n  public constructor(\n    msg?: string,\n    transform?: TransformFn<Input, Parent, Root>\n  ) {\n    super();\n    if (transform) {\n      this.transform(transform);\n    } else {\n      this.transform(parseString);\n    }\n    this.addTest(v => typeof v === 'string', msg || 'Must be a string');\n  }\n\n  /**\n   * Verify that the string is an exact length\n   * @param len required length of array\n   * @param msg error message if test fails\n   */\n  public length(len: number, msg?: string) {\n    this.addTest(v => v.length === len, msg || `Must have length ${len}`);\n    return this;\n  }\n\n  /**\n   * Verify that the string is at least a certain length\n   * @param min the minimum valid length\n   * @param msg error message if test fails\n   */\n  public min(min: number, msg?: string) {\n    this.addTest(\n      v => v.length >= min,\n      msg || `Must have length greater than or equal to ${min}`\n    );\n    return this;\n  }\n\n  /**\n   * Verify that the string is at most a certain length\n   * @param max the maximum valid length\n   * @param msg error message if test fails\n   */\n  public max(max: number, msg?: string) {\n    this.addTest(\n      v => v.length <= max,\n      msg || `Must have length less than or equal to ${max}`\n    );\n    return this;\n  }\n\n  /**\n   * Verify that the string matches a regular expression\n   * @param regex regular expression to use\n   * @param msg error message if test fails\n   */\n  public matches(regex: RegExp, msg?: string) {\n    this.addTest(\n      v => regex.test(v),\n      msg || `Must match regular expression: ${regex.toString()}`\n    );\n    return this;\n  }\n\n  /**\n   * Verify that the string is an email address\n   * @param msg error message if test fails\n   */\n  public email(msg?: string) {\n    this.addTest(v => emailRegex.test(v), msg || `Must be an email address`);\n    return this;\n  }\n\n  private addTest = this.makeAddTest<string>();\n}\n\nexport default OKString;\n"]}